package it.trading;

import com.google.gson.*;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class BybitAccumulationScanner {

    private static final String BASE_URL = "https://api.bybit.com";
    private final HttpClient client = HttpClient.newHttpClient();
    private final Gson gson = new Gson();
    private final String telegramToken = System.getenv("TELEGRAM_BOT_TOKEN");
    private final String telegramChatId = System.getenv("TELEGRAM_CHAT_ID");

    private String get(String endpoint) throws Exception {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(BASE_URL + endpoint))
                .GET()
                .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        if (response.statusCode() != 200) throw new RuntimeException("API error: " + response.body());
        return response.body();
    }

    private boolean isHammer(JsonArray kline) {
        String openStr = kline.get(1).getAsString();
        String highStr = kline.get(2).getAsString();
        String lowStr = kline.get(3).getAsString();
        String closeStr = kline.get(4).getAsString();

        double open = Double.parseDouble(openStr);
        double high = Double.parseDouble(highStr);
        double low = Double.parseDouble(lowStr);
        double close = Double.parseDouble(closeStr);

        double body = Math.abs(open - close);
        double range = high - low;
        if (range == 0) return false;

        double lowerShadow = Math.min(open, close) - low;
        double upperShadow = high - Math.max(open, close);

        return body <= 0.3 * range &&
               lowerShadow >= 2 * body &&
               upperShadow <= 0.5 * body &&
               close > open;
    }

    private double getBidRatioNotional(String symbol) throws Exception {
        String json = get("/v5/market/orderbook?category=linear&symbol=" + symbol + "&limit=500");
        JsonObject root = gson.fromJson(json, JsonObject.class);
        JsonObject result = root.getAsJsonObject("result");
        JsonArray bids = result.getAsJsonArray("b");
        JsonArray asks = result.getAsJsonArray("a");

        double totalBid = 0;
        double totalAsk = 0;

        for (JsonElement e : bids) {
            JsonArray level = e.getAsJsonArray();
            double price = Double.parseDouble(level.get(0).getAsString());
            double qty = Double.parseDouble(level.get(1).getAsString());
            totalBid += price * qty;
        }
        for (JsonElement e : asks) {
            JsonArray level = e.getAsJsonArray();
            double price = Double.parseDouble(level.get(0).getAsString());
            double qty = Double.parseDouble(level.get(1).getAsString());
            totalAsk += price * qty;
        }

        if (totalBid + totalAsk == 0) return 0;
        return totalBid / (totalBid + totalAsk);
    }

    private void sendTelegram(String message) {
        if (telegramToken == null || telegramChatId == null) {
            System.out.println("Telegram non configurato - alert: " + message);
            return;
        }
        try {
            String url = "https://api.telegram.org/bot" + telegramToken +
                    "/sendMessage?chat_id=" + telegramChatId +
                    "&text=" + URLEncoder.encode(message, StandardCharsets.UTF-8) +
                    "&parse_mode=HTML&disable_web_page_preview=true";
            client.send(HttpRequest.newBuilder().uri(URI.create(url)).GET().build(),
                    HttpResponse.BodyHandlers.ofString());
        } catch (Exception e) {
            System.err.println("Errore Telegram: " + e.getMessage());
        }
    }

    private void scan() {
        try {
            String tickersJson = get("/v5/market/tickers?category=linear");
            JsonObject tickersRoot = gson.fromJson(tickersJson, JsonObject.class);
            JsonArray list = tickersRoot.getAsJsonObject("result").getAsJsonArray("list");

            List<Map.Entry<String, Double>> candidates = new ArrayList<>();
            for (JsonElement elem : list) {
                JsonObject item = elem.getAsJsonObject();
                String symbol = item.get("symbol").getAsString();
                if (!symbol.endsWith("USDT")) continue;

                String turnoverStr = item.get("turnover24h").getAsString();
                double turnover24h = Double.parseDouble(turnoverStr);
                if (turnover24h < 5_000_000) continue;

                candidates.add(new AbstractMap.SimpleEntry<>(symbol, turnover24h));
            }

            candidates.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));
            List<String> topSymbols = new ArrayList<>();
            for (int i = 0; i < Math.min(100, candidates.size()); i++) {
                topSymbols.add(candidates.get(i).getKey());
            }

            System.out.println("Scanning " + topSymbols.size() + " top Bybit perpetual...");

            for (String symbol : topSymbols) {
                try {
                    Thread.sleep(100);

                    String klineJson = get("/v5/market/kline?category=linear&symbol=" + symbol + "&interval=60&limit=2");
                    JsonObject klineRoot = gson.fromJson(klineJson, JsonObject.class);
                    JsonArray klines = klineRoot.getAsJsonObject("result").getAsJsonArray("list");
                    if (klines.size() < 2) continue;

                    JsonArray lastClosed = klines.get(0).getAsJsonArray();

                    if (!isHammer(lastClosed)) continue;

                    double bidRatio = getBidRatioNotional(symbol);
                    if (bidRatio < 0.65) continue;

                    JsonObject tickerItem = null;
                    for (JsonElement e : list) {
                        JsonObject it = e.getAsJsonObject();
                        if (it.get("symbol").getAsString().equals(symbol)) {
                            tickerItem = it;
                            break;
                        }
                    }
                    if (tickerItem == null) continue;

                    double price = Double.parseDouble(tickerItem.get("lastPrice").getAsString());
                    double funding = Double.parseDouble(tickerItem.get("fundingRate").getAsString());

                    String fundingEmoji = funding < 0 ? "ðŸ”¥ NEGATIVO (shorts pagano!)" : "â„ï¸ positivo";

                    String msg = "ðŸš€ <b>ACCUMULAZIONE POTENZIALE BYBIT</b> ðŸš€\n\n" +
                            "<b>" + symbol + "</b>\n" +
                            "Prezzo attuale: <b>$" + String.format("%.4f", price) + "</b>\n" +
                            "Hammer bullish 1H âœ…\n" +
                            "Bid ratio (notional): <b>" + String.format("%.2f%%", bidRatio * 100) + "</b> âœ…\n" +
                            "Funding rate: <b>" + String.format("%.5f%%", funding * 100) + "</b> " + fundingEmoji + "\n\n" +
                            "<a href='https://www.tradingview.com/chart/?symbol=BYBIT:" + symbol + "'>TradingView Chart</a> | " +
                            "<a href='https://www.bybit.com/trade/usdt/" + symbol + "'>Trade su Bybit</a>";

                    sendTelegram(msg);
                    System.out.println("ðŸš€ ALERT INVIATO: " + symbol);

                } catch (Exception e) {
                    System.err.println("Errore su " + symbol + ": " + e.getMessage());
                }
            }
        } catch (Exception e) {
            System.err.println("Errore scan generale: " + e.getMessage());
        }
    }

    public static void main(String[] args) {
        BybitAccumulationScanner scanner = new BybitAccumulationScanner();

        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

        long now = System.currentTimeMillis();
        long nextHourMillis = ((now / 3600000) + 1) * 3600000;
        long target = nextHourMillis + 60000;
        long initialDelay = target - now;
        if (initialDelay < 0) initialDelay += 3600000;

        scheduler.scheduleAtFixedRate(scanner::scan, initialDelay, 3600000, TimeUnit.MILLISECONDS);

        System.out.println("Scanner avviato. Prossimo scan tra ~" + (initialDelay / 60000) + " minuti");
    }
}
